exports.name="notify";exports.version="0.0.1";exports.disabled=false;exports.handleSignals=true;exports.group=C.INTERNAL_FUNCTION_GROUP;let group,searchId,savedQueryId,notificationId,message,messageTemplate,authToken,messagesEndpoint,searchUrl,logger,comparatorExpression,trigger="true",triggerCount=0,triggerExpression,resultsLimit=10,triggerCounter=0,triggerType="resultsCount",triggerComparator=">",notificationResults=[],notificationSent=false,signalCounter=0,utLogger=undefined,tenantId=undefined;const{RestVerb}=C.internal.HttpUtils;const{createRequest}=C.internal.kusto;const createNotification=(e,t,r,i,n,o,s,a)=>({id:`SEARCH_NOTIFICATION_${t}_${e}`,severity:"info",_raw:r,title:`Scheduled search notification`,_time:e,now:e,group,searchId:n,savedQueryId:o,searchResultsUrl:s,notificationId:t,resultSet:i,tenantId:a,message:r,origin_metadata:{itemType:"link",id:n,type:"search",product:"search",groupId:""}});const comparators=[">","<","===","!==",">=","<="];exports.init=async e=>{trigger="true";triggerCount=0;triggerExpression;resultsLimit=10;triggerCounter=0;triggerType="resultsCount";triggerComparator=">";notificationResults=[];const t=e.conf;({searchId,message,savedQueryId,authToken,messagesEndpoint,searchUrl,utLogger,notificationId,tenantId}=t);logger=utLogger??C.util.getLogger(`func:notify:${searchId}`);messageTemplate=new C.internal.kusto.Template(message,false,logger);group=t.group??group;trigger=t.trigger??trigger;triggerExpression=new C.expr.Expression(trigger);resultsLimit=t.resultsLimit??resultsLimit;triggerCount=t.triggerCount??triggerCount;triggerType=t.triggerType??triggerType;triggerComparator=t.triggerComparator??triggerComparator;if(!comparators.includes(triggerComparator)){throw new Error(`Unknown comparator ${triggerComparator}`)}comparatorExpression=new C.expr.Expression(`triggerCounter ${triggerComparator} triggerCount`);logger.info("Initialized notify",{...t})};exports.process=async e=>{if(e.__signalEvent__==="final"&&!notificationSent){if(comparatorExpression.evalOn({triggerCounter,triggerCount})){await sendNotification(notificationResults)}}if(e.__signalEvent__==="reset"){signalCounter++;if(signalCounter>1)logger.error("Signal event received in notify pipeline function, which cannot handle previews",{signalCounter})}if(e.__signalEvent__!=null||triggerType==="custom"&&!triggerExpression.evalOn(e))return e;triggerCounter++;if(notificationResults.length<resultsLimit){const t=e.asObject();if(t.cribl_route){delete t.cribl_route}notificationResults.push(t)}return e};async function sendNotification(e){notificationSent=true;const t=new Date;const r=messageTemplate.render({resultSet:e,savedQueryId,searchId,searchResultsUrl:searchUrl,notificationId,timestamp:t.toISOString(),tenantId});const i=createNotification(t.getTime(),notificationId,r,e,searchId,savedQueryId,searchUrl,tenantId);await sendNotificationMessage(i)}async function sendNotificationMessage(e){const t=3;const r=1e3;for(let i=0;i<=t;i++){try{logger.debug("Sending message",{notiMessage:e});const t={url:messagesEndpoint,method:RestVerb.POST,payload:e};const r=await createRequest(t).addAuthToken(authToken).run();await r.readAsJSON();return}catch(e){logger.error("Error posting notification message",{error:e});logger.error("Sending attempt failed.");if(i<t){logger.info(`Retrying... Attempt ${i+1} of ${t}`);await new Promise((e=>setTimeout(e,r)))}else{throw new Error(`Failed to send bulletin message after ${t} attempts`)}}}}exports.unload=()=>{messageTemplate?.dispose();triggerExpression=undefined;notificationResults=undefined};