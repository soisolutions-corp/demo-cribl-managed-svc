exports.name="Distinct";exports.version="0.1.3";exports.disabled=false;exports.handleSignals=true;exports.group=C.INTERNAL_FUNCTION_GROUP;exports.sync=true;const DEFAULT_MAX_DISTINCT_COMBINATIONS=1e4;const DEFAULT_MAX_DEPTH=15;const{NestedPropertyAccessor}=C.expr;const criblInternalField=C.internal.criblInternalField;let logger;let maxCombinations;let maxDepth;let groupBy;let isFederated;let singleEventProcessor;let distinctCombinations;let root;let knownFields;let cancelTriggered;exports.init=e=>{const t=e.conf??{};maxCombinations=t.maxCombinations??DEFAULT_MAX_DISTINCT_COMBINATIONS;maxDepth=t.maxDepth??DEFAULT_MAX_DEPTH;isFederated=t.isFederated??false;let n="";for(let e=0;e<5;++e)n+=String.fromCodePoint("a".charCodeAt(0)+Math.floor(Math.random()*26));logger=C.util.getLogger(`func:distinct`,{funcInstId:n});groupBy=t.groupBy??["*"];if(!Array.isArray(groupBy)||groupBy.length===0||groupBy.length===1&&groupBy[0]==="*"){groupBy=[]}else if(groupBy.length>maxDepth){groupBy=groupBy.splice(0,maxDepth);logger.error("limiting list of specified groupBy fields",{groupBy});throw new Error("distinct function: number of groupBy fields larger than maxDepth configuration value")}switch(groupBy.length){case 0:logger.debug("wildcard mode",{isFederated});singleEventProcessor=buildWildCardDistinct;break;case 1:logger.debug("single groupBy mode",{isFederated});groupBy=new NestedPropertyAccessor(groupBy[0]);singleEventProcessor=buildDistinctSingle;break;default:groupBy=groupBy.map((e=>new NestedPropertyAccessor(e)));logger.debug("multiple groupBy mode",{groupBy,isFederated});singleEventProcessor=buildDistinctFixed;break}reset()};exports.unload=()=>{groupBy=undefined;root=undefined;knownFields=undefined};exports.process=e=>{if(!e)return e;if(e.__signalEvent__){if(e.__signalEvent__!=="close"){logger.debug("signal event received",{event:e.__signalEvent__})}switch(e.__signalEvent__){case"reset":reset();return e;case"final":case"complete_gen":case"timer":return flush(e);default:return e}}if(distinctCombinations<maxCombinations){singleEventProcessor(e)}else if(!cancelTriggered){logger.debug("reached maxCombinations, canceling query");cancelTriggered=true;const t=e.__clone(false,[]);t.__signalEvent__="cancel";t.__setCtrlField("reason","distinct");return t}};function flush(e){let t=[];if(!isFederated){const n=e.__clone(false,[]);n.__signalEvent__="reset";n.__setCtrlField("distinct",e.__signalEvent__??"preview");t.push(n)}if(singleEventProcessor===buildWildCardDistinct){flushWildCardDistinct(e.__clone(false,[]),t,root)}else if(singleEventProcessor===buildDistinctFixed){flushDistinctFixed(e.__clone(false,[]),t,root)}else{flushDistinctSingle(e,t)}if(e.__signalEvent__!=="complete_gen"&&!isFederated){const n=e.__clone(false,[]);n.__signalEvent__="complete_gen";n.__setCtrlField("distinct","preview");t.push(n)}t.push(e);return t}function buildWildCardDistinct(e){if(groupBy.length<maxDepth){for(const t of Object.keys(e).filter((e=>!criblInternalField(e)))){if(!knownFields.has(t)){groupBy.push(t);knownFields.add(t);if(groupBy.length===maxDepth){logger.info("limiting list of dynamically created groupBy fields",{groupBy});break}}}}buildMapPath(e,false)}function buildDistinctFixed(e){const t=buildMapPath(e);const n=mapValue(groupBy[groupBy.length-1].get(e));if(!t.has(n)){++distinctCombinations;t.add(n)}}function buildDistinctSingle(e){root.add(mapValue(groupBy.get(e)));distinctCombinations=root.size}function flushWildCardDistinct(e,t,n,i=0){const o=groupBy[i];if(i<groupBy.length-1){for(const[s,r]of n.entries()){const n=e.__clone(false);n[o]=s;flushWildCardDistinct(n,t,r,i+1)}}else{for(const i of n.keys()){const n=e.__clone(false);n[o]=i;t.push(n)}}}function flushDistinctFixed(e,t,n,i=0){const o=groupBy[i];if(n instanceof Map){for(const[s,r]of n.entries()){const n=e.__clone(false);o.deepSet(n,s);flushDistinctFixed(n,t,r,i+1)}}else{for(const i of n){const n=e.__clone(false);o.deepSet(n,i);t.push(n)}}}function flushDistinctSingle(e,t){for(const n of root){const i=e.__clone(false,[]);groupBy.deepSet(i,n);t.push(i)}}function buildMapPath(e,t=true){let n=root;for(let i=0;i<groupBy.length-(t?1:0);++i){const o=mapValue(t?groupBy[i].get(e):e[groupBy[i]]);let s=n.get(o);if(s==null){s=i<groupBy.length-2?new Map:t?new Set:new Map;n.set(o,s);if(!t&&i===groupBy.length-1){++distinctCombinations}}n=s}return n}function mapValue(e){if(e==null)return null;if(typeof e==="object")return JSON.stringify(e);return e}function reset(){if(singleEventProcessor===buildWildCardDistinct){root=new Map;knownFields=new Set;groupBy=[]}else if(singleEventProcessor===buildDistinctFixed){root=new Map}else{root=new Set}cancelTriggered=false;distinctCombinations=0}