exports.jobType="task-per-node";exports.name="worker_upgrade";const os=require("os");let upgradeClient;let packages;let authToken;const{internal:{performPackageDownload}}=C;exports.initJob=async e=>{const{conf:a}=e.conf.executor;packages=[];await Promise.all(a.packages.map((async e=>{const{packageFile:a,packageUrl:t,hashUrl:r,hashFile:s,hashType:n}=e;try{await performPackageDownload(t,a,r,s,n);packages.push(e)}catch{}})));if(!packages.length)throw new Error("Failed to download packages.");authToken=a.authToken};exports.jobSeedTask=async()=>({task:{packages,authToken}});exports.initTask=async e=>{if(C.internal.newUpgradeClient){upgradeClient=C.internal.newUpgradeClient()}else{upgradeClient=new C.internal.UpgradeClient}};exports.jobOnError=async(e,a,t)=>{};exports.taskExecute=async(e,a)=>{const t=e.logger();const r=[os.platform(),os.arch()];const s=a.packages.find((e=>e.variant[0]===r[0]&&e.variant[1]===r[1]));if(!s){e.reportError(new Error(`Could not find a suitable package for ${r.join(", ")}`),"TASK_FATAL");return}const n={packageUrl:s.localPackageUrl,hashUrl:s.localHashUrl,version:s.version};t.info("task opts",{opts:a});t.info("Checking upgradeability",{...n});let o;o=await upgradeClient.checkUpgradePath(n,e.logger());if(!o.canUpgrade){t.info(o.message);e.addResult(o);return}t.info("Fetching assets");const i=await upgradeClient.downloadAssets(n,a.authToken);t.info("Fetched assets",i);if(n.hashUrl){t.info("Verifying assets");await upgradeClient.verifyAssets(i);t.info("Assets verified")}t.info("Proceeding to installation");o=await upgradeClient.installPackage(i,o);t.info(o.message);if(!o.isSuccess){e.reportError(new Error(o.message),"TASK_FATAL");return}await e.addResult(o);setImmediate((()=>upgradeClient.restartServer().catch((()=>{}))))};